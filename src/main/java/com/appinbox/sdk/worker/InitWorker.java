package com.appinbox.sdk.worker;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Context;import android.os.Build;import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.core.app.NotificationCompat;import androidx.work.Data;import androidx.work.ForegroundInfo;import androidx.work.WorkManager;import androidx.work.Worker;import androidx.work.WorkerParameters;import com.appinbox.sdk.R;import com.appinbox.sdk.auth.Device;import com.appinbox.sdk.svc.ApiBuilder;import retrofit2.Call;import retrofit2.Callback;import retrofit2.Response;import static android.content.Context.NOTIFICATION_SERVICE;public class InitWorker extends Worker {    private static final Integer NOTIF_ID = 12311;    private NotificationManager notificationManager;    public InitWorker(            @NonNull Context context,            @NonNull WorkerParameters parameters) {        super(context, parameters);        notificationManager = (NotificationManager)                context.getSystemService(NOTIFICATION_SERVICE);    }    @NonNull    @Override    public Result doWork() {        Data inputData = getInputData();        String appId = inputData.getString(WorkerVars.KEY_APP_ID);        String appKey = inputData.getString(WorkerVars.KEY_APP_KEY);        String contact = inputData.getString(WorkerVars.KEY_CONTACT);        String deviceId = inputData.getString(WorkerVars.KEY_DEVICE_ID);        String progress = "Initializing app inbox";        // Mark the Worker as important        setForegroundAsync(createForegroundInfo(progress));        initialize(appId, appKey, contact, deviceId);        return Result.success();    }    private void initialize(String appId, String appKey, String contact, String deviceId) {        Device device = new Device(deviceId);        try {            Thread.sleep(10000);        } catch (InterruptedException e) {            e.printStackTrace();        }        ApiBuilder.getInstance().registerDevice(appId, appKey, contact, device).enqueue(new Callback<Device>() {            @Override            public void onResponse(Call<Device> call, Response<Device> response) {                if (response.body() != null) {                notificationManager.cancel(NOTIF_ID);//                    setupRecyclerView(response.body());                } else {                    notificationManager.cancel(NOTIF_ID);//                    showFailed();                }//                pullToRefresh.setRefreshing(false);            }            @Override            public void onFailure(Call<Device> call, Throwable t) {                notificationManager.cancel(NOTIF_ID);//                showFailed();//                pullToRefresh.setRefreshing(false);            }        });    }    @NonNull    private ForegroundInfo createForegroundInfo(@NonNull String progress) {        // Build a notification using bytesRead and contentLength        Context context = getApplicationContext();        String id = context.getString(R.string.default_notification_channel_id);        String title = context.getString(R.string.notif_init_title);        String cancel = context.getString(R.string.notif_cancel);        // This PendingIntent can be used to cancel the worker        PendingIntent intent = WorkManager.getInstance(context)                .createCancelPendingIntent(getId());        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {            createChannel();        }        Notification notification = new NotificationCompat.Builder(context, id)                .setContentTitle(title)                .setTicker(title)                .setSmallIcon(R.drawable.ic_stat_ic_notification)                .setOngoing(true)                // Add the cancel action to the notification which can                // be used to cancel the worker                .addAction(android.R.drawable.ic_delete, cancel, intent)                .build();        return new ForegroundInfo(NOTIF_ID, notification);    }    @RequiresApi(Build.VERSION_CODES.O)    private void createChannel() {        // Create a Notification channel    }}